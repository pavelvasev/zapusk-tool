# Спецификации работы zapusk-tool-v1

Zapusk-tool это интерпетатор запуск-программ.

Он работает в целом по алгоритму, описанному в
https://github.com/pavelvasev/zapusk/blob/master/solution.md

Таких интерпретаторов в принципе может быть множество.
В данном случае речь идет о конкретном текущем интерпретаторе,
далее он будет называться zapusk-tool-v1. 

Zapusk-tool-v1 накладывает свои особенности на интерпретацию,
которые перечислены ниже.

## Каталоги состояния
Каждая запуск-программа имеет свой корневой каталог состояния,
определяемый параметром **state_dir** в файле **zapusk.conf**.

В каталоге состояния хранятся:

### Состояние компонент
Состояние каждой компоненты запуск-программы, содержащей zdb-шаг,
сохраняется в каталоге **state_dir/compound-name**.

Каталог состояния компоненты точно такой же, как и каталог
состояния программы, описываемый здесь.

### Перечень созданных компонент
Сохраняется в каталоге **state_dir/_zapusk.created**
в файлах: **state_dir/_zapusk.created/compound-name*

### Архив удаленных компонент
Сохраняется в каталоге **state_dir/_zapusk.removed**

### файл params.sh
Параметры работы компоненты в формате шелл.

### файл params.txt
Параметры работы компоненты в формате ini без заголовков.

### файл zapusk.conf
Параметры, необходимые для выполнения zapusk-tool, если его вызвать
из каталога состояния компоненты. 

Эти параметры требуются для удаления исчезнувших компонент.

## Удаление исчезнувших компонент
Для реализации требования [O2](https://github.com/pavelvasev/zapusk/blob/master/task.md)
хранится перечень созданных компонент (см выше).

Этот перечень позволяет понимать, какие компоненты были
развернуты через apply или другие команды, но затем
удалены пользователем в запуск-программы, и как следствие
подлежат destroy со стороны запуска.

Сообразно, перед каждый выполнением запуск-программы
производится проверка этих списков, и если обнаруживаются
удаленные пользователем, но развернутые компоненты,
то происходит их удаление: destroy + помещение в архив.

См remove_removed_components, [src.v1/z1_65_state_manage.rb](src.v1/z1_65_state_manage.rb)

## О создании каталогов компонент
Принято решение, что для каждой компоненты запуск-программы необходимо создавать отдельный каталог
состояния, но только если в этой компоненте содержится шаг типа zdb.

Это позволяет описывать разные os-шаги, опираясь на текущую запуск-компоненту, 
и находиться в контексте ее параметров.

## Вычисление global_name
global_name это длинное имя развернутого экземпляра компоненты, учитывающее весь путь к этой компоненте от корня вычислений.
Имея global_name, можно смело регистрировать его в общих областях машины, например создавать файлы `/etc/init.d/{{global_naame}}`

Пусть есть текущая zdb-компонента z. У нее есть вложенная компонента b. Тогда: 
`b.global_name = z.global_name + "-" + b.name.`
где z.global_name это global_name текущей компоненты, а b.name это имя компоненты b.

Например, пусть есть каталог z.zdb с файлом main.ini следующего содержанияж
```
####### alfa
...
####### beta
...
```
И пусть z используется сама как компонента где-то, и имеет например имя "some-path".
Тогда экземпляр компонеты alfa получит global_namе равный "some-path-alfa", а beta получит "some-path-beta".

см [src.v1/z1_15_global_name.rb](src.v1/z1_15_global_name.rb)


## Передача информации о последующих шагах zdb-типам

Компонента состоит из шагов. Если в середине цепочки шагов очередной шаг это специальный шаг,
реализуемый в интерпретаторе, то проблем нет - следующие шаги передаются ему как аргумент.
Но если очередной шаг это zdb-тип, то:
1. создается новый экземпляр интерпретатора Zapusk, и настраивается.
2. последующие шаги цепочки передаются ему в атрибуте Zapusk::expression_args
3. Кроме того, эти шаги (будучи ini-секциями) сохраняются в каталог компоненты в файлах вида arg_i.ini

Таким образом, zdb-компонента имеет доступ к "аргументам-шагам" - т.е. интерпретатор делает ее функтором.

См [src.v1/types/zdb.rb](src.v1/types/zdb.rb)

## Встроенный руби

zapusk-tool-v1 написан на руби. Чтобы не конфликтовать с системными руби (или их отсутствием), а также
чтобы иметь руби внутри виртуальных машин, которые управляются через zapusk-tool, принято решение
таскать за собой двоичную версию руби. 

Скрипт [download-rest-and-setup.sh](download-rest-and-setup.sh)
* загружает руби из интернета в папку zapusk-tool/ruby.local
* создает ссылку zapusk на [src.v1/zapusk-ruby-local](src.v1/zapusk-ruby-local), чтобы zapusk-tool
использовал этот встроенный руби.

## Архитектура zapusk-tool-v1
Сделана по модели "добавок". Корневой файл [src.v1/z1.rb](src.v1/z1.rb) загружает подряд
все файлы из каталога [src.v1](src.v1), которые соединяются по методу ruby prepend.
В итоге формируется 1 класс Zapusk, в котором реализовано и загрузка компонент, и их представление
в оперативной памяти, и их интерпретация.

Главный командный файл [src.v1/zapusk.rb](src.v1/zapusk.rb) загружает указанную запуск-программу,
параметры команды, и вызывает интерпретацию этой запуск-программы (Zapusk::perform).


## Очередь заданий

Кроме прямого выполнения задач, zapusk-tool-v1 поддерживает очередь заданий.

Любой компонент запуск-программы может добавить задание в очередь.
Для он может добавить строку в файл, путь к которому записан в переменной окружения ZAPUSK_DEFERRED_PATH.

Формат файла:
```
key-name1 = command1
key-name2 = command2
```

* Задания в очередь выполняются после того, как выполнятся все основные задания.
* Если в файле несколько строк с одинаковым key-name, то будет выполнена только последняя.
* Если в файл добавят строки во время выполнения отложенных заданий, то цикл будет повторен до 10 раз.

---

Экземпляр программы zapusk-tool-v1 определяет, является ли он ответственным за очередь, по переменной
ZAPUSK_DEFERRED_PATH. Если она пуста - то он ее заполняет и становится ответственным.
Путь к файлу выбирается по алгоритму, указаному в [src.v1/z1_BB_deferred.rb](src.v1/z1_BB_deferred.rb)

Также можно указать ключ командной строки --deferred-master, что означает что этот экзепляр должен
начать и вести свою очередь. Это полезно для обработки очередей в виртуальных машинах.
